# My O(n), but slow sliding window solution
```py
class Solution:
    def longestBeautifulSubstring(self, word: str) -> int:
        res = l = 0
        for r in range(len(word)):
            if r-l < 1:
                pass
            else: # at least two chars long
                now = word[r]
                last = word[r-1]
            
                if now == "a" and last != "a":
                    l = r
                
                if now == "e" and last != "e" and last != "a":
                    l = r

                if now == "i" and last != "i" and last != "e":
                    l = r

                if now == "o" and last != "o" and last != "i":
                    l = r
                
                if now == "u" and last != "u" and last != "o":
                    l = r
                elif now == "u" and word[l] == "a":
                    res = max(res, r-l+1)        
        return res
```
- - -
# AI cleaned up my logic
```py
class Solution:
    def longestBeautifulSubstring(self, word: str) -> int:
        res = 0
        l = 0
        
        for r in range(len(word)):
            if r == 0:
                continue

            now  = word[r]
            last = word[r - 1]

            # invalid transitions → reset window start
            if (
                (now == "a" and last != "a") or
                (now == "e" and last not in "ae") or
                (now == "i" and last not in "ei") or
                (now == "o" and last not in "io") or
                (now == "u" and last not in "ou")
            ):
                l = r

            # valid sequence covering all vowels → update result
            if now == "u" and word[l] == "a":
                res = max(res, r - l + 1)

        return res
```