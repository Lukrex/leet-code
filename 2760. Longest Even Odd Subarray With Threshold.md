# My unoptimized O(n) sliding window solution
```py
class Solution:
    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:
        res = l = 0
        for r in range(len(nums)):
            while r-l+1!=1 and nums[l]%2!=0 or r-l+1!=1 and nums[r]>threshold or r-l+1!=1 and nums[r-1]%2==nums[r]%2 or r-l+1!=1 and nums[l]>threshold:
                l += 1
                print(l)
            if nums[l]%2==0 and r-l+1==1 and nums[r]<=threshold:
                res = max(res, r-l+1)
            elif nums[l]%2==0 and nums[r-1]%2!=nums[r]%2 and nums[r]<=threshold:
                res = max(res, r-l+1)
        return res
```
# AI optimized solution
```py
class Solution:
    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:
        res = 0
        l = 0

        for r in range(len(nums)):            
            # If an element breaks the threshold rule, window must restart
            if nums[r] > threshold:
                l = r + 1
                continue

            # Check starting parity rule
            if nums[l] % 2 != 0:
                l = r
                continue

            # Check alternating parity (only matters when window length > 1)
            if r > l and nums[r] % 2 == nums[r-1] % 2:
                l = r

            res = max(res, r - l + 1)

        return res
```